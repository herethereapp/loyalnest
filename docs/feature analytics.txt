Herethere Loyalty App Feature Analysis
=========================

## Customer Widget Features (Phase 1, 2, 3)

********************************************
Feature Name: Points Earning
********************************************

Goal: Allow customers to earn points for actions like purchases, signups, or reviews to encourage loyalty and engagement.

Key Features:

	• Points awarded for purchases (e.g., 1 point per $), signups (e.g., 200 points), reviews (100 points), birthdays (200 points).
	• Automatic point calculation via Shopify order sync (webhook).
	• Real-time balance update in Customer Widget.
	• Notification of points earned (e.g., "You earned 100 points!").
	• Caching for performance (Redis).

Database Design (Simplified):

	• Table: points_transactions
		○ transaction_id (text, PK): Unique transaction ID.
		○ customer_id (text, FK → customers): Customer earning points.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ type (text): Action type (e.g., "purchase", "signup").
		○ points (integer): Points awarded.
		○ source (text): Source of points (e.g., "order").
		○ order_id (text): Linked Shopify order.
	• Table: customers
		○ points_balance (integer): Current balance.
		○ total_points_earned (integer): Cumulative points.
	• Indexes: idx_points_transactions_customer_id for fast lookups.

API Sketch:

	• POST /points/earn
		○ Input: { customer_id: string, order_id: string, action_type: string }
		○ Output: { status: "success", transaction_id: string, points: number }
		○ Flow: Validate order via Shopify webhook, insert into points_transactions, update customers.points_balance, update Redis cache.


********************************************
Feature Name: Points Redemption
********************************************
Goal: Enable customers to redeem points for rewards (e.g., discounts, free shipping) to incentivize purchases.

Key Features:

	• Display available rewards (e.g., $5 off for 500 points).
	• Deduct points upon redemption and issue discount code.
	• Update balance in real-time.
	• Handle insufficient points with error message.
	• Log redemption for analytics.

Database Design (Simplified):

	• Table: rewards
		○ reward_id (text, PK): Unique reward ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ type (text): Reward type (e.g., "discount").
		○ points_cost (integer): Points required.
		○ value (numeric): Reward value (e.g., 5.00).
	• Table: reward_redemptions
		○ redemption_id (text, PK): Unique redemption ID.
		○ customer_id (text, FK → customers): Redeeming customer.
		○ reward_id (text, FK → rewards): Redeemed reward.
		○ points_spent (integer): Points used.
		○ discount_code (text): Issued code.
		○ status (text): Redemption status (e.g., "issued").
	• Table: customers
		○ points_balance (integer): Updated balance.
		○ total_points_redeemed (integer): Cumulative points spent.
	• Indexes: idx_reward_redemptions_customer_id for performance.

API Sketch:

	• POST /rewards/redeem
		○ Input: { customer_id: string, reward_id: string }
		○ Output: { status: "success", redemption_id: string, discount_code: string }
		○ Flow: Check points_balance, insert into reward_redemptions, deduct points from customers.points_balance, update Redis cache.

********************************************
Feature Name: Referral Program
********************************************
Goal: Allow customers to refer friends and earn rewards to increase customer acquisition.

Key Features:

	• Generate unique referral link/code for sharing via SMS, email, social media (Phase 2).
	• Award points to advocate when friend signs up or purchases.
	• Track referral status (e.g., pending, completed).
	• Send notifications via Twilio/Klaviyo.
	• Display referral options in Customer Widget.

Database Design (Simplified):

	• Table: referral_links
		○ referral_link_id (text, PK): Unique link ID.
		○ advocate_customer_id (text, FK → customers): Referring customer.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ referral_code (text, UK): Unique code.
	• Table: referrals
		○ referral_id (text, PK): Unique referral ID.
		○ advocate_customer_id (text, FK → customers): Advocate.
		○ friend_customer_id (text, FK → customers): Friend.
		○ reward_id (text, FK → rewards): Reward for advocate.
		○ status (text): Referral status (e.g., "completed").
	• Table: points_transactions
		○ transaction_id (text, PK): For referral reward points.
		○ type (text): "referral".
	• Indexes: idx_referral_links_referral_code for fast lookup.

API Sketch:

	• POST /referrals/create
		○ Input: { advocate_customer_id: string }
		○ Output: { referral_code: string }
		○ Flow: Insert into referral_links, return code.
	• POST /referrals/complete
		○ Input: { referral_code: string, friend_customer_id: string }
		○ Output: { status: "success", referral_id: string }
		○ Flow: Insert into referrals, award points via points_transactions, notify via Twilio.

********************************************
Feature Name: VIP Tiers (Phase 2)
********************************************
Goal: Reward loyal customers with tiered benefits based on spending to enhance retention.

Key Features:

	• Define tiers (e.g., Silver: $100+, Gold: $500+) with perks (e.g., early access).
	• Display customer’s current tier and progress in Widget.
	• Notify customers of tier changes via email.
	• Apply earning multipliers for higher tiers.

Database Design (Simplified):

	• Table: vip_tiers
		○ vip_tier_id (text, PK): Unique tier ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ threshold_value (numeric): Spending threshold.
		○ earning_multiplier (numeric): Points multiplier.
		○ perks (jsonb): Perks (e.g., {"early_access": true}).
		○ entry_reward_id (text, FK → rewards): Entry reward.
	• Table: customers
		○ vip_tier_id (text, FK → vip_tiers): Customer’s tier.
	• Table: email_events
		○ event_id (text, PK): For tier change notifications.
		○ event_type (text): "tier_change".

API Sketch:

	• GET /vip-tiers/status
		○ Input: { customer_id: string }
		○ Output: { tier_name: string, progress: number, perks: object }
		○ Flow: Query customers.vip_tier_id, vip_tiers for details.
	• POST /vip-tiers/update
		○ Input: { customer_id: string, vip_tier_id: string }
		○ Output: { status: "success" }
		○ Flow: Update customers.vip_tier_id, log in email_events.

********************************************
Feature Name: RFM Nudges (Phase 2)
********************************************
Goal: Encourage customer engagement by displaying nudges based on RFM (Recency, Frequency, Monetary) scores.

Key Features:

	• Display nudges (e.g., "Stay Active!") based on RFM segments.
	• Log nudge interactions for analytics.
	• Customize nudge content per merchant.
	• Show in Customer Widget as popup or banner.

Database Design (Simplified):

	• Table: nudges
		○ nudge_id (text, PK): Unique nudge ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ type (text): Nudge type (e.g., "at-risk").
		○ title (jsonb): Multilingual title.
		○ description (jsonb): Multilingual description.
		○ is_enabled (boolean): Active status.
	• Table: nudge_events
		○ event_id (text, PK): Interaction ID.
		○ customer_id (text, FK → customers): Interacting customer.
		○ nudge_id (text, FK → nudges): Nudge shown.
		○ action (text): Action taken (e.g., "dismiss").
	• Table: customers
		○ rfm_score (jsonb): RFM metrics (e.g., {"recency": 30, "frequency": 2}).

API Sketch:

	• GET /nudges
		○ Input: { customer_id: string }
		○ Output: { nudge_id: string, title: string, description: string }
		○ Flow: Query nudges based on customers.rfm_score.
	• POST /nudges/action
		○ Input: { customer_id: string, nudge_id: string, action: string }
		○ Output: { status: "success" }
		○ Flow: Insert into nudge_events.

********************************************
Feature Name: Gamification (Phase 3)
********************************************
Goal: Motivate customers with badges and leaderboards to increase engagement.

Key Features:

	• Award badges for actions (e.g., purchases, referrals).
	• Display leaderboard rank in Customer Widget.
	• Track achievements for analytics.
	• Notify customers of new badges.

Database Design (Simplified):

	• Table: gamification_achievements (assumed, not in schema; would need migration)
		○ achievement_id (text, PK): Unique badge ID.
		○ customer_id (text, FK → customers): Awarded customer.
		○ badge (text): Badge name (e.g., "Loyal Customer").
		○ created_at (timestamp): Award date.
	• Table: customers
		○ points_balance (integer): For leaderboard ranking.

API Sketch:

	• POST /gamification/action
		○ Input: { customer_id: string, action_type: string }
		○ Output: { achievement_id: string, badge: string }
		○ Flow: Insert into gamification_achievements, notify customer.
	• GET /gamification/leaderboard
		○ Input: { customer_id: string }
		○ Output: { rank: number, total: number }
		○ Flow: Query customers.points_balance for ranking.

********************************************
Feature Name: Multilingual Support (Phase 3)
********************************************
Goal: Allow customers to interact with the Widget in their preferred language to improve accessibility.

Key Features:

	• Display language dropdown in Widget.
	• Persist language choice in browser session.
	• Support merchant-defined languages (e.g., English, Spanish).
	• Update UI dynamically (e.g., points labels).

Database Design (Simplified):

	• Table: merchants
		○ language (varchar): Default language (e.g., "en").
	• Table: nudges
		○ title (jsonb): Multilingual titles (e.g., {"en": "Stay Active", "es": "Sigue Activo"}).
		○ description (jsonb): Multilingual descriptions.

API Sketch:

	• GET /widget/config
		○ Input: { merchant_id: string }
		○ Output: { language: string, translations: object }
		○ Flow: Query merchants.language, nudges.title for translations.



## Merchant Dashboard Features (Phase 1, 2, 3)

********************************************
Feature Name: Setup Wizard
********************************************

Goal: Guide merchants through initial setup to launch their loyalty program quickly.

Key Features:

	• Display tasks (e.g., "Add Widget", "Configure Points") on Welcome Page.
	• Track task completion.
	• Show congratulatory messages upon completion.
	• Save progress for later resumption.

Database Design (Simplified):

	• Table: program_settings
		○ merchant_id (text, PK, FK → merchants): Merchant ID.
		○ config (jsonb): Setup progress (e.g., {"tasks_completed": ["widget", "points"]}).
API Sketch:

	• POST /settings/setup
		○ Input: { merchant_id: string, task: string }
		○ Output: { status: "success", tasks_completed: array }
		○ Flow: Update program_settings.config, return updated tasks.

********************************************
Feature Name: Points Program Configuration
********************************************

Goal: Enable merchants to customize points earning and redemption rules to align with their business.

Key Features:

	• Set earning rules (e.g., 1 point per $, 200 points for signup).
	• Define redemption options (e.g., $5 off for 500 points).
	• Customize branding (e.g., points currency as "Stars").
	• Toggle program on/off.

Database Design (Simplified):

	• Table: program_settings
		○ points_currency_singular (text): Currency name (e.g., "Star").
		○ points_currency_plural (text): Plural form (e.g., "Stars").
		○ config (jsonb): Rules (e.g., {"purchase": 1, "signup": 200}).
		○ branding (jsonb): Branding settings.
	• Table: rewards
		○ points_cost (integer): Points for redemption.
		○ value (numeric): Reward value.

API Sketch:

	• PUT /points-program
		○ Input: { merchant_id: string, config: object, branding: object }
		○ Output: { status: "success" }
		○ Flow: Update program_settings, rewards.

********************************************
Feature Name: Referrals Program Configuration
********************************************

Goal: Allow merchants to set up a referral program to drive customer acquisition.

Key Features:

	• Configure referral rewards (e.g., 10% off for both).
	• Enable SMS/email sharing via Twilio/Klaviyo.
	• Preview referral popup.
	• Toggle program on/off (Phase 2).

Database Design (Simplified):

	• Table: program_settings
		○ config (jsonb): Referral settings (e.g., {"reward": "10% off", "sms_enabled": true}).
	• Table: email_templates
		○ template_id (text, PK): Referral email template.
		○ type (text): "referral".

API Sketch:

	• PUT /referrals/config
		○ Input: { merchant_id: string, config: object }
		○ Output: { status: "success" }
		○ Flow: Update program_settings.config, email_templates.

********************************************
Feature Name: Customer Management
********************************************

Goal: Provide merchants with tools to view and manage customer data for better engagement.

Key Features:

	• List customers with name, email, points, RFM score.
	• Search by name/email.
	• View detailed customer profiles (e.g., points history).
	• Handle large customer lists with pagination.

Database Design (Simplified):

	• Table: customers
		○ customer_id (text, PK): Unique ID.
		○ email (text): Customer email.
		○ first_name (text), last_name (text): Customer name.
		○ points_balance (integer): Current points.
		○ rfm_score (jsonb): RFM metrics.
	• Indexes: idx_customers_email for search performance.

API Sketch:

	• GET /customers
		○ Input: { merchant_id: string, search: string, page: number }
		○ Output: { customers: array, total: number }
		○ Flow: Query customers with pagination and search.

********************************************
Feature Name: Analytics Dashboard
********************************************

Goal: Enable merchants to monitor loyalty program performance with metrics and RFM charts.

Key Features:

	• Display metrics (e.g., program members, points issued, referral ROI).
	• Show RFM segment charts (Chart.js).
	• Export reports (Phase 3).
	• Handle large datasets efficiently.

Database Design (Simplified):

	• Table: customer_segments
		○ segment_id (text, PK): Unique segment ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ rules (jsonb): RFM rules (e.g., {"recency": "<30 days"}).
	• Table: points_transactions
		○ For metrics like points issued/redeemed.
	• Table: customers
		○ rfm_score (jsonb): For segment calculations.

API Sketch:

	• GET /analytics
		○ Input: { merchant_id: string }
		○ Output: { metrics: object, segments: array }
		○ Flow: Query customer_segments, points_transactions, customers.
	• GET /analytics/export (Phase 3)
		○ Input: { merchant_id: string }
		○ Output: CSV file
		○ Flow: Generate CSV from customer_segments, customers.

********************************************
Feature Name: Store Settings
********************************************

Goal: Allow merchants to configure store details and billing plans to manage their account.

Key Features:

	• Update store name, billing plan (e.g., Free, $29/mo).
	• Save branding settings (e.g., rewards panel style).
	• Validate inputs for consistency.
	• Display current plan status.

Database Design (Simplified):

	• Table: merchants
		○ merchant_id (text, PK): Unique ID.
		○ shopify_domain (text, UK): Store domain.
		○ plan_id (text): Billing plan.
		○ brand_settings (jsonb): Branding config.
	• Table: plans
		○ plan_id (text, PK): Plan ID.
		○ order_limit (integer): Order cap.
		○ base_price (numeric): Plan cost.

API Sketch:

	• PUT /settings
		○ Input: { merchant_id: string, store_name: string, plan_id: string, brand_settings: object }
		○ Output: { status: "success" }
		○ Flow: Update merchants.

********************************************
Feature Name: On-Site Content Management
********************************************

Goal: Enable merchants to customize loyalty page, popups, and launcher button to align with their brand.

Key Features:

	• Edit SEO-friendly loyalty page.
	• Customize rewards panel and launcher button.
	• Configure post-purchase and exit-intent popups (Phase 2).
	• Enable sticky bar (Phase 3).

Database Design (Simplified):

	• Table: program_settings
		○ branding (jsonb): Content settings (e.g., {"loyalty_page": {...}, "popup": {...}}).
	• Table: email_templates
		○ template_id (text, PK): For popup notifications.
		○ type (text): "popup".

API Sketch:

	• PUT /content
		○ Input: { merchant_id: string, branding: object }
		○ Output: { status: "success", preview: object }
		○ Flow: Update program_settings.branding, email_templates.

********************************************
Feature Name: VIP Tiers Management (Phase 2)
********************************************

Goal: Allow merchants to define and manage VIP tiers to reward loyal customers.

Key Features:

	• Create/edit tiers (e.g., Silver, Gold) with spending thresholds.
	• Set perks and multipliers.
	• Notify customers of tier changes.
	• Preview tier structure in Dashboard.

Database Design (Simplified):

	• Table: vip_tiers
		○ vip_tier_id (text, PK): Unique ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ name (text): Tier name.
		○ threshold_value (numeric): Spending threshold.
		○ perks (jsonb): Perks list.
	• Table: email_templates
		○ type (text): "tier_change".

API Sketch:

	• POST /vip-tiers
		○ Input: { merchant_id: string, name: string, threshold_value: number, perks: object }
		○ Output: { vip_tier_id: string }
		○ Flow: Insert into vip_tiers, update email_templates.

********************************************
Feature Name: Activity Logs (Phase 2)
********************************************

Goal: Provide merchants with logs of customer actions for transparency and tracking.

Key Features:

	• Display points, referral, and VIP change logs.
	• Filter by customer or date.
	• Show detailed action info.
	• Handle large logs with pagination.

Database Design (Simplified):

	• Table: points_transactions
		○ transaction_id (text, PK): For points logs.
		○ type (text): Action type.
	• Table: referrals
		○ referral_id (text, PK): For referral logs.
		○ status (text): Referral status.
	• Table: customers
		○ vip_tier_id (text): For tier change logs.

API Sketch:

	• GET /logs
		○ Input: { merchant_id: string, filter: object, page: number }
		○ Output: { logs: array, total: number }
		○ Flow: Query points_transactions, referrals, customers.

********************************************
Feature Name: RFM Configuration (Phase 2)
********************************************

Goal: Enable merchants to configure RFM thresholds for customer segmentation.

Key Features:

	• Set recency, frequency, monetary thresholds via wizard.
	• Preview segment distribution.
	• Save settings for analytics.
	• Validate inputs for consistency.

Database Design (Simplified):

	• Table: program_settings
		○ config (jsonb): RFM thresholds (e.g., {"recency": "<30 days"}).
	• Table: customer_segments
		○ rules (jsonb): Segment rules.
		○ name (text): Segment name (e.g., "At-Risk").

API Sketch:

	• PUT /rfm/config
		○ Input: { merchant_id: string, thresholds: object }
		○ Output: { status: "success" }
		○ Flow: Update program_settings.config, customer_segments.

********************************************
Feature Name: Checkout Extensions (Phase 2)
********************************************

Goal: Display points balance at checkout to encourage redemptions.

Key Features:

	• Enable/disable points display in Shopify checkout.
	• Show balance and redemption options.
	• Integrate via Shopify API.
	• Preview in Dashboard.

Database Design (Simplified):

	• Table: program_settings
		○ config (jsonb): Checkout settings (e.g., {"checkout_enabled": true}).
	• Table: integrations
		○ type (text): "shopify".
		○ settings (jsonb): Checkout config.

API Sketch:

	• PUT /content
		○ Input: { merchant_id: string, checkout_config: object }
		○ Output: { status: "success" }
		○ Flow: Update program_settings.config, integrations.settings.

********************************************
Feature Name: Bonus Campaigns (Phase 3)
********************************************

Goal: Allow merchants to create time-sensitive campaigns to boost engagement.

Key Features:

	• Set campaign types (e.g., double points, goal spend).
	• Define start/end dates and multipliers.
	• Notify customers via email/SMS.
	• Track campaign performance.

Database Design (Simplified):

	• Table: bonus_campaigns
		○ campaign_id (text, PK): Unique ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ type (text): Campaign type.
		○ multiplier (numeric): Points multiplier.
		○ start_date, end_date (timestamp): Campaign duration.
		○ conditions (jsonb): Campaign rules.
	• Table: points_transactions
		○ type (text): "campaign".

API Sketch:

	• POST /campaigns
		○ Input: { merchant_id: string, type: string, multiplier: number, dates: object }
		○ Output: { campaign_id: string }
		○ Flow: Insert into bonus_campaigns, notify via email_templates.

********************************************
Feature Name: Advanced Reports Export (Phase 3)
********************************************

Goal: Enable merchants to export detailed analytics for in-depth analysis.

Key Features:

	• Export RFM segments and revenue data as CSV.
	• Show export progress.
	• Ensure data accuracy.
	• Log export actions.

Database Design (Simplified):

	• Table: customer_segments
		○ segment_id (text, PK): For segment data.
		○ rules (jsonb): Segment rules.
	• Table: points_transactions
		○ For revenue and redemption data.
	• Table: api_logs
		○ id (text, PK): Log export actions.

API Sketch:

	• GET /analytics/export
		○ Input: { merchant_id: string }
		○ Output: CSV file
		○ Flow: Query customer_segments, points_transactions, log in api_logs.

********************************************
Feature Name: Sticky Bar (Phase 3)
********************************************

Goal: Promote the loyalty program with a sticky bar on the store website.

Key Features:

	• Enable/disable sticky bar in Dashboard.
	• Customize bar content and style.
	• Preview in real-time.
	• Track engagement via analytics.

Database Design (Simplified):

	• Table: program_settings
		○ branding (jsonb): Sticky bar settings (e.g., {"sticky_bar": {"text": "Join Now!"}}).

API Sketch:

	• PUT /content
		○ Input: { merchant_id: string, sticky_bar: object }
		○ Output: { status: "success" }
		○ Flow: Update program_settings.branding.

********************************************
Feature Name: Developer Toolkit (Phase 3)
********************************************

Goal: Provide advanced customization for merchants via metafields and APIs.

Key Features:

	• Configure metafields for Shopify integration.
	• Save settings securely.
	• Validate inputs.
	• Preview changes in Dashboard.

Database Design (Simplified):

	• Table: integrations
		○ integration_id (text, PK): Integration ID.
		○ settings (jsonb): Metafield configs (e.g., {"metafields": {...}}).
	• Table: api_logs
		○ For logging toolkit actions.

API Sketch:

	• PUT /settings/developer
		○ Input: { merchant_id: string, metafields: object }
		○ Output: { status: "success" }
		○ Flow: Update integrations.settings, log in api_logs.




## Admin Module Features (Phase 1, 2, 3)

********************************************
Feature Name: Merchant Overview
********************************************

Goal: Provide admins with a high-level view of platform usage and metrics.

Key Features:

	• Display merchant count, points issued, referral ROI.
	• Show aggregated RFM charts.
	• Filter by time period.
	• Handle large datasets.

Database Design (Simplified):

	• Table: merchants
		○ merchant_id (text, PK): For counting merchants.
	• Table: points_transactions
		○ For points metrics.
	• Table: customer_segments
		○ For RFM data.

API Sketch:

	• GET /admin/overview
		○ Input: { period: string }
		○ Output: { metrics: object, charts: array }
		○ Flow: Query merchants, points_transactions, customer_segments.

********************************************
Feature Name: Merchant Management
********************************************

Goal: Allow admins to view and manage merchant accounts for platform oversight.

Key Features:

	• List merchants with ID, domain, plan.
	• Search by ID/domain.
	• View detailed merchant profiles.
	• Paginate large lists.

Database Design (Simplified):

	• Table: merchants
		○ merchant_id (text, PK): Unique ID.
		○ shopify_domain (text, UK): Store domain.
		○ plan_id (text): Current plan.
	• Indexes: merchants_shopify_domain_key for search.

API Sketch:

	• GET /admin/merchants
		○ Input: { search: string, page: number }
		○ Output: { merchants: array, total: number }
		○ Flow: Query merchants with pagination.

********************************************
Feature Name: Points Adjustment
********************************************

Goal: Enable admins to adjust customer points for corrections or bonuses.

Key Features:

	• Adjust points via form.
	• Log adjustments for auditing.
	• Update customer balance.
	• Notify customer of change.

Database Design (Simplified):

	• Table: points_transactions
		○ transaction_id (text, PK): For adjustment record.
		○ type (text): "admin_adjust".
	• Table: customers
		○ points_balance (integer): Updated balance.
	• Table: audit_logs
		○ id (uuid, PK): Log adjustment.
		○ admin_user_id (integer, FK → admin_users): Admin performing action.

API Sketch:

	• POST /admin/points/adjust
		○ Input: { merchant_id: string, customer_id: string, points: number }
		○ Output: { status: "success", transaction_id: string }
		○ Flow: Insert into points_transactions, update customers.points_balance, log in audit_logs.

********************************************
Feature Name: Admin User Management
********************************************

Goal: Allow admins to manage platform access for other admins.

Key Features:

	• Add/edit/delete admin users.
	• Validate unique username/email.
	• Log actions for security.
	• Display admin list with roles.

Database Design (Simplified):

	• Table: admin_users
		○ id (integer, PK): Unique ID.
		○ username (text, UK): Unique username.
		○ email (text, UK): Unique email.
	• Table: audit_logs
		○ For logging user management actions.

API Sketch:

	• POST /admin/users
		○ Input: { username: string, email: string, password: string }
		○ Output: { id: number }
		○ Flow: Insert into admin_users, log in audit_logs.
	• PUT/DELETE /admin/users/{id}
		○ Input: { username: string, email: string } (PUT)
		○ Output: { status: "success" }
		○ Flow: Update/delete admin_users, log in audit_logs.

********************************************
Feature Name: Log Management
********************************************

Goal: Provide admins with API and audit logs for platform monitoring.

Key Features:

	• Display API and audit logs with filters (date, user).
	• Show detailed log info.
	• Paginate large logs.
	• Ensure secure access.

Database Design (Simplified):

	• Table: api_logs
		○ id (text, PK): Log ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ route (text), method (text), status_code (integer): Log details.
	• Table: audit_logs
		○ id (uuid, PK): Audit log ID.
		○ admin_user_id (integer, FK → admin_users): Admin action.

API Sketch:

	• GET /admin/logs
		○ Input: { filter: object, page: number }
		○ Output: { logs: array, total: number }
		○ Flow: Query api_logs, audit_logs with filters.

********************************************
Feature Name: Plan Management (Phase 2)
********************************************

Goal: Allow admins to manage merchant billing plans for revenue control.

Key Features:

	• Upgrade/downgrade merchant plans (e.g., Free to $29/mo).
	• Display current plan and limits.
	• Log plan changes.
	• Notify merchants of changes.

Database Design (Simplified):

	• Table: merchants
		○ plan_id (text): Current plan.
	• Table: plans
		○ plan_id (text, PK): Plan ID.
		○ order_limit (integer): Order cap.
		○ base_price (numeric): Cost.
	• Table: audit_logs
		○ For logging plan changes.

API Sketch:

	• PUT /admin/plans
		○ Input: { merchant_id: string, plan_id: string }
		○ Output: { status: "success" }
		○ Flow: Update merchants.plan_id, log in audit_logs, notify via email_templates.

********************************************
Feature Name: Integration Health Monitoring (Phase 2)
********************************************

Goal: Ensure platform reliability by monitoring integration status (e.g., Shopify, Twilio).

Key Features:

	• Display integration status (e.g., "OK", "Error").
	• Allow manual health checks.
	• Log checks for auditing.
	• Notify admins of failures.

Database Design (Simplified):

	• Table: integrations
		○ integration_id (text, PK): Unique ID.
		○ merchant_id (text, FK → merchants): Associated merchant.
		○ type (text): Integration type (e.g., "shopify").
		○ status (text): Health status.
	• Table: audit_logs
		○ For logging health checks.

API Sketch:

	• GET /admin/integrations/health
		○ Input: { merchant_id: string }
		○ Output: { integrations: array }
		○ Flow: Query integrations, ping external APIs, log in audit_logs.

********************************************
Feature Name: RFM Configuration Management (Phase 2)
********************************************

Goal: Allow admins to manage RFM settings for optimal customer segmentation.

Key Features:

	• Configure RFM thresholds for merchants.
	• Preview segment distribution.
	• Save settings securely.
	• Log changes for auditing.

Database Design (Simplified):

	• Table: program_settings
		○ config (jsonb): RFM thresholds.
	• Table: customer_segments
		○ rules (jsonb): Segment rules.
	• Table: audit_logs
		○ For logging changes.

API Sketch:

	• PUT /admin/rfm
		○ Input: { merchant_id: string, thresholds: object }
		○ Output: { status: "success" }
		○ Flow: Update program_settings.config, customer_segments, log in audit_logs.

********************************************
Feature Name: RFM Segment Export (Phase 3)
********************************************

Goal: Enable admins to export RFM segments for detailed analysis.

Key Features:

	• Export segments as CSV.
	• Show export progress.
	• Ensure data accuracy.
	• Log export actions.

Database Design (Simplified):

	• Table: customer_segments
		○ segment_id (text, PK): Segment ID.
		○ rules (jsonb): Segment rules.
	• Table: customers
		○ rfm_score (jsonb): Customer RFM data.
	• Table: audit_logs
		○ For logging exports.

API Sketch:

	• GET /admin/rfm/export
		○ Input: { merchant_id: string }
		○ Output: CSV file
		○ Flow: Query customer_segments, customers, log in audit_logs.

********************************************
Feature Name: Advanced Integrations (Phase 3)
********************************************

Goal: Support additional platforms (e.g., Square, Lightspeed) for broader compatibility.

Key Features:

	• Configure new integrations via API keys.
	• Save settings securely.
	• Test integration connectivity.
	• Log setup actions.

Database Design (Simplified):

	• Table: integrations
		○ integration_id (text, PK): Unique ID.
		○ type (text): New platform (e.g., "square").
		○ api_key (text): API key.
		○ settings (jsonb): Integration config.
	• Table: audit_logs
		○ For logging setup.

API Sketch:

	• POST /admin/integrations
		○ Input: { merchant_id: string, type: string, api_key: string, settings: object }
		○ Output: { integration_id: string }
		○ Flow: Insert into integrations, log in audit_logs.



## Backend Integration Features (Phase 1, 2, 3)

********************************************
Feature Name: Shopify Order Sync
********************************************

Goal: Automatically sync Shopify orders to award points seamlessly.

Key Features:

	• Receive order webhooks from Shopify.
	• Calculate and award points based on rules.
	• Update customer balance and cache.
	• Log sync actions.

Database Design (Simplified):

	• Table: points_transactions
		○ transaction_id (text, PK): Sync record.
		○ type (text): "purchase".
		○ order_id (text): Shopify order ID.
	• Table: customers
		○ points_balance (integer): Updated balance.
	• Table: api_logs
		○ For logging webhook calls.

API Sketch:

	• POST /points/earn
		○ Input: { order_id: string, customer_id: string }
		○ Output: { status: "success", transaction_id: string }
		○ Flow: Validate webhook, insert into points_transactions, update customers.points_balance, log in api_logs.

********************************************
Feature Name: Referral Notifications
********************************************

Goal: Notify customers of referral rewards via email/SMS for engagement.

Key Features:

	• Send notifications using Twilio/Klaviyo.
	• Use merchant-defined templates.
	• Log notification events.
	• Handle delivery failures with retries.

Database Design (Simplified):

	• Table: email_templates
		○ template_id (text, PK): Notification template.
		○ type (text): "referral".
		○ subject (text), body (text): Content.
	• Table: email_events
		○ event_id (text, PK): Event ID.
		○ event_type (text): "sent".
		○ recipient_email (text): Target email.

API Sketch:

	• POST /notifications/send
		○ Input: { template_id: string, recipient_email: string }
		○ Output: { status: "success" }
		○ Flow: Query email_templates, send via Twilio/Klaviyo, insert into email_events.

********************************************
Feature Name: Customer Data Import (Phase 2)
********************************************

Goal: Import existing customer data from integrations to onboard merchants.

Key Features:

	• Import customer records via API.
	• Validate data integrity.
	• Log import success/failures.
	• Update customer records.

Database Design (Simplified):

	• Table: customers
		○ customer_id (text, PK): Imported customer.
		○ email (text), first_name (text), last_name (text): Customer data.
	• Table: import_logs
		○ id (text, PK): Log ID.
		○ success_count (integer), fail_count (integer): Import results.
		○ fail_reason (text): Error details.

API Sketch:

	• POST /data/import
		○ Input: { merchant_id: string, customers: array }
		○ Output: { status: "success", success_count: number, fail_count: number }
		○ Flow: Insert into customers, log in import_logs.

********************************************
Feature Name: Campaign Discounts (Phase 3)
********************************************

Goal: Apply discounts from bonus campaigns to enhance customer rewards.

Key Features:

	• Check active campaigns for point multipliers.
	• Apply discounts via Rust/Wasm Shopify Functions.
	• Update points and cache.
	• Log campaign applications.

Database Design (Simplified):

	• Table: bonus_campaigns
		○ campaign_id (text, PK): Campaign ID.
		○ multiplier (numeric): Points multiplier.
		○ conditions (jsonb): Campaign rules.
	• Table: points_transactions
		○ type (text): "campaign".
	• Table: api_logs
		○ For logging discount applications.

API Sketch:

	• POST /campaigns/apply
		○ Input: { customer_id: string, order_id: string }
		○ Output: { status: "success", points: number }
		○ Flow: Query bonus_campaigns, apply multiplier, insert into points_transactions, log in api_logs.
