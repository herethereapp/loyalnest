LoyalNest App Feature Analysis
=========================

## Customer Widget Features (Phase 1, 2, 3)

********************************************
Feature Name: Points Earning
********************************************

Goal: Allow customers to earn points for actions like purchases, signups, reviews, or birthdays to encourage loyalty and engagement. Success metric: 90%+ successful point awards within 1s.

Key Features:
- Points awarded for purchases (1 point/$), signups (200 points), reviews (100 points), birthdays (200 points).
- Automatic point calculation via Shopify `orders/create` webhook with signature verification.
- Real-time balance update in Customer Widget using Storefront API.
- Notification of points earned (e.g., "You earned 100 points!") via Klaviyo.
- Caching for performance (Redis, partitioned `points_transactions` for Plus-scale).

Database Design:
- Table: points_transactions
  - transaction_id (text, PK, NOT NULL): Unique transaction ID.
  - customer_id (text, FK → customers, NOT NULL): Customer earning points.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL, CHECK type IN ('purchase', 'signup', 'review', 'birthday')): Action type.
  - points (integer, NOT NULL, CHECK points > 0): Points awarded.
  - source (text): Source (e.g., "order").
  - order_id (text): Linked Shopify order ID.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Transaction timestamp.
- Table: customers
  - customer_id (text, PK, NOT NULL): Unique customer ID.
  - points_balance (integer, NOT NULL, DEFAULT 0): Current balance.
  - total_points_earned (integer, NOT NULL, DEFAULT 0): Cumulative points.
- Indexes: idx_points_transactions_customer_id, idx_points_transactions_merchant_id
- Partition: points_transactions by merchant_id for Plus-scale performance (50,000+ customers).

API Sketch:
- POST /v1/api/points/earn
  - Input: { customer_id: string, order_id: string, action_type: string }
  - Output: { status: string, transaction_id: string, points: number, error: { code: string, message: string } | null }
  - Flow: Validate order via GraphQL Admin API, verify webhook signature, insert into points_transactions, update customers.points_balance, cache in Redis, handle rate limits (2 req/s REST, 40 req/s Plus) with exponential backoff, track via PostHog (e.g., `points_earned`).
- GraphQL Query (Admin API):
  - Query: order(id: "gid://shopify/Order/123") { id, totalPrice, customer { id } }
  - Flow: Validate order, calculate points (1 point/$).

********************************************
Feature Name: Points Redemption
********************************************

Goal: Enable customers to redeem points for rewards (e.g., discounts, free shipping) to incentivize purchases. Success metric: 85%+ redemption success rate for Plus merchants.

Key Features:
- Display available rewards (e.g., $5 off for 500 points) in widget via Storefront API.
- Deduct points and issue discount code via GraphQL Admin API.
- Update balance in real-time, cache in Redis.
- Handle insufficient points with error message.
- Log redemption for analytics, encrypt discount_code.

Database Design:
- Table: rewards
  - reward_id (text, PK, NOT NULL): Unique reward ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL, CHECK type IN ('discount', 'free_shipping', 'free_product')): Reward type.
  - points_cost (integer, NOT NULL, CHECK points_cost > 0): Points required.
  - value (numeric, NOT NULL, CHECK value > 0): Reward value (e.g., 5.00).
- Table: reward_redemptions
  - redemption_id (text, PK, NOT NULL): Unique redemption ID.
  - customer_id (text, FK → customers, NOT NULL): Redeeming customer.
  - reward_id (text, FK → rewards, NOT NULL): Redeemed reward.
  - points_spent (integer, NOT NULL, CHECK points_spent > 0): Points used.
  - discount_code (text, UNIQUE, ENCRYPTED): Issued discount code.
  - status (text, NOT NULL, CHECK status IN ('issued', 'used', 'expired')): Redemption status.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Redemption timestamp.
- Table: customers
  - points_balance (integer, NOT NULL, DEFAULT 0): Updated balance.
  - total_points_redeemed (integer, NOT NULL, DEFAULT 0): Cumulative points spent.
- Indexes: idx_reward_redemptions_customer_id, idx_reward_redemptions_merchant_id
- Partition: reward_redemptions by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/rewards/redeem
  - Input: { customer_id: string, reward_id: string }
  - Output: { status: string, redemption_id: string, discount_code: string, error: { code: string, message: string } | null }
  - Flow: Validate points_balance, create discount via GraphQL Admin API, insert into reward_redemptions, deduct points, update Redis cache, handle rate limits (2 req/s REST, 40 req/s Plus), track via PostHog (e.g., `points_redeemed`).
- GraphQL Mutation (Admin API):
  - Mutation: discountCodeBasicCreate(basicCodeDiscount: { title: "Loyalty Discount", code: "DISC_123", value: 5.0 }) { discountCode { id } }
  - Flow: Create discount code, link to redemption.

********************************************
Feature Name: Referral Program
********************************************

Goal: Allow customers to refer friends and earn rewards to increase customer acquisition. Success metric: 5%+ referral conversion rate.

Key Features:
- Generate unique referral link/code for sharing via SMS, email, social media (Phase 2) using Twilio/Klaviyo.
- Award points to advocate when friend signs up or purchases (e.g., 10% off for both).
- Track referral status (pending, completed, expired) via Storefront API.
- Send notifications with 3 retries (exponential backoff).
- Display referral options in Customer Widget with localized content.

Database Design:
- Table: referral_links
  - referral_link_id (text, PK, NOT NULL): Unique link ID.
  - advocate_customer_id (text, FK → customers, NOT NULL): Referring customer.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - referral_code (text, UNIQUE, NOT NULL): Unique code.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Creation timestamp.
- Table: referrals
  - referral_id (text, PK, NOT NULL): Unique referral ID.
  - advocate_customer_id (text, FK → customers, NOT NULL): Advocate.
  - friend_customer_id (text, FK → customers, NOT NULL): Friend.
  - reward_id (text, FK → rewards): Reward for advocate.
  - status (text, NOT NULL, CHECK status IN ('pending', 'completed', 'expired')): Referral status.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Referral timestamp.
- Table: points_transactions
  - transaction_id (text, PK): For referral reward points.
  - type (text, NOT NULL): "referral".
- Indexes: idx_referral_links_referral_code, idx_referrals_merchant_id
- Partition: referrals by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/referrals/create
  - Input: { advocate_customer_id: string }
  - Output: { status: string, referral_code: string, error: { code: string, message: string } | null }
  - Flow: Validate input, insert into referral_links, return unique code, cache in Redis.
- POST /v1/api/referrals/complete
  - Input: { referral_code: string, friend_customer_id: string }
  - Output: { status: string, referral_id: string, error: { code: string, message: string } | null }
  - Flow: Verify webhook signature (customers/create), validate referral_code, insert into referrals, award points via points_transactions, notify via Twilio/Klaviyo with retries, update Redis cache, track via PostHog (e.g., `referral_completed`).

********************************************
Feature Name: VIP Tiers (Phase 2)
********************************************

Goal: Reward loyal customers with tiered benefits based on spending to enhance retention. Success metric: 10%+ tier engagement rate.

Key Features:
- Define tiers (e.g., Silver: $100+, Gold: $500+) with perks (e.g., early access, multipliers).
- Display customer’s current tier and progress in Widget via Storefront API.
- Notify customers of tier changes via Klaviyo.
- Apply earning multipliers for higher tiers using GraphQL Admin API.
- Enforce RBAC for multi-user tier management (Shopify Plus).

Database Design:
- Table: vip_tiers
  - vip_tier_id (text, PK, NOT NULL): Unique tier ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - name (text, NOT NULL): Tier name (e.g., "Silver").
  - threshold_value (numeric, NOT NULL, CHECK threshold_value >= 0): Spending threshold.
  - earning_multiplier (numeric, NOT NULL, CHECK earning_multiplier >= 1): Points multiplier.
  - perks (jsonb, NOT NULL): Perks (e.g., {"early_access": true}).
  - entry_reward_id (text, FK → rewards): Entry reward.
- Table: customers
  - vip_tier_id (text, FK → vip_tiers): Customer’s tier.
- Table: email_events
  - event_id (text, PK, NOT NULL): For tier change notifications.
  - event_type (text, NOT NULL): "tier_change".
  - recipient_email (text, ENCRYPTED): Target email.
- Indexes: idx_vip_tiers_merchant_id, idx_customers_vip_tier_id
- Partition: vip_tiers by merchant_id for Plus-scale performance.

API Sketch:
- GET /v1/api/vip-tiers/status
  - Input: { customer_id: string, locale: string }
  - Output: { status: string, tier_name: string, progress: number, perks: object, error: { code: string, message: string } | null }
  - Flow: Query customers.vip_tier_id, vip_tiers via GraphQL Admin API, cache in Redis, use Storefront API for localized content.
- POST /v1/api/vip-tiers/update
  - Input: { customer_id: string, vip_tier_id: string }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate input, update customers.vip_tier_id via GraphQL Admin API, log in email_events, notify via Klaviyo, enforce RBAC, cache in Redis.

********************************************
Feature Name: RFM Nudges (Phase 2)
********************************************

Goal: Encourage customer engagement by displaying nudges based on RFM (Recency, Frequency, Monetary) scores. Success metric: 10%+ nudge interaction rate.

Key Features:
- Display nudges (e.g., "Stay Active!") based on RFM segments in widget via Storefront API.
- Log nudge interactions in nudge_events for analytics, track via PostHog.
- Customize nudge content per merchant with multilingual support (JSONB).
- Show as popup or banner with localized content.

Database Design:
- Table: nudges
  - nudge_id (text, PK, NOT NULL): Unique nudge ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL, CHECK type IN ('at-risk', 'loyal', 'new')): Nudge type.
  - title (jsonb, NOT NULL): Multilingual title (e.g., {"en": "Stay Active", "es": "Sigue Activo"}).
  - description (jsonb, NOT NULL): Multilingual description.
  - is_enabled (boolean, NOT NULL, DEFAULT true): Active status.
- Table: nudge_events
  - event_id (text, PK, NOT NULL): Interaction ID.
  - customer_id (text, FK → customers, NOT NULL): Interacting customer.
  - nudge_id (text, FK → nudges, NOT NULL): Nudge shown.
  - action (text, NOT NULL, CHECK action IN ('view', 'click', 'dismiss')): Action taken.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Event timestamp.
- Table: customers
  - rfm_score (jsonb, NOT NULL): RFM metrics (e.g., {"recency": 30, "frequency": 2, "monetary": 100}).
- Indexes: idx_nudges_merchant_id, idx_nudge_events_customer_id
- Partition: nudge_events by merchant_id for Plus-scale performance.

API Sketch:
- GET /v1/api/nudges
  - Input: { customer_id: string, locale: string }
  - Output: { status: string, nudge_id: string, title: string, description: string, error: { code: string, message: string } | null }
  - Flow: Query nudges based on customers.rfm_score, use Storefront API for localized content, cache in Redis, track via PostHog (e.g., `nudge_viewed`).
- POST /v1/api/nudges/action
  - Input: { customer_id: string, nudge_id: string, action: string }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate input, insert into nudge_events, track via PostHog (e.g., `rfm_nudge_action`), cache in Redis.

********************************************
Feature Name: Gamification (Phase 3)
********************************************

Goal: Motivate customers with badges and leaderboards to increase engagement. Success metric: 15%+ gamification engagement rate.

Key Features:
- Award badges for actions (e.g., purchases, referrals) via Storefront API.
- Display leaderboard rank in Customer Widget using Redis sorted sets.
- Track achievements in gamification_achievements for analytics.
- Notify customers of new badges via Klaviyo.

Database Design:
- Table: gamification_achievements
  - achievement_id (text, PK, NOT NULL): Unique badge ID.
  - customer_id (text, FK → customers, NOT NULL): Awarded customer.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - badge (text, NOT NULL): Badge name (e.g., "Loyal Customer").
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Award date.
- Table: customers
  - points_balance (integer, NOT NULL): For leaderboard ranking.
- Indexes: idx_gamification_achievements_customer_id, idx_gamification_achievements_merchant_id
- Partition: gamification_achievements by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/gamification/action
  - Input: { customer_id: string, action_type: string }
  - Output: { status: string, achievement_id: string, badge: string, error: { code: string, message: string } | null }
  - Flow: Validate input, insert into gamification_achievements, notify via Klaviyo, cache in Redis, track via PostHog (e.g., `badge_earned`).
- GET /v1/api/gamification/leaderboard
  - Input: { customer_id: string }
  - Output: { status: string, rank: number, total: number, error: { code: string, message: string } | null }
  - Flow: Query Redis sorted set for ranking based on customers.points_balance, cache in Redis.

********************************************
Feature Name: Multilingual Support (Phase 3)
********************************************

Goal: Allow customers to interact with the Widget in their preferred language to improve accessibility. Success metric: 80%+ multilingual widget adoption.

Key Features:
- Display language dropdown in Widget via Storefront API.
- Persist language choice in browser session (localStorage).
- Support merchant-defined languages (e.g., ["en", "es"]) in merchants.language.
- Update UI dynamically (e.g., points labels, nudges) with localized content.

Database Design:
- Table: merchants
  - merchant_id (text, PK, NOT NULL): Unique ID.
  - language (jsonb, NOT NULL): Supported languages (e.g., ["en", "es"]).
- Table: nudges
  - title (jsonb, NOT NULL): Multilingual titles (e.g., {"en": "Stay Active", "es": "Sigue Activo"}).
  - description (jsonb, NOT NULL): Multilingual descriptions.
- Indexes: idx_merchants_language

API Sketch:
- GET /v1/api/widget/config
  - Input: { merchant_id: string, locale: string }
  - Output: { status: string, language: string, translations: { points_label: string, rewards: object }, error: { code: string, message: string } | null }
  - Flow: Query merchants.language, nudges.title/description via Storefront API, cache translations in Redis, track via PostHog (e.g., `language_selected`).

## Merchant Dashboard Features (Phase 1, 2, 3)

********************************************
Feature Name: Setup Wizard
********************************************

Goal: Guide merchants through initial setup to launch their loyalty program quickly. Success metric: 80%+ task completion rate.

Key Features:
- Display tasks (e.g., "Add Widget", "Configure Points", "Configure RBAC" for Plus) on Welcome Page.
- Track task completion in program_settings.config.
- Show congratulatory messages upon completion.
- Save progress for later resumption, support Plus-specific tasks (e.g., multi-user setup).

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - config (jsonb, NOT NULL): Setup progress (e.g., {"tasks_completed": ["widget", "points", "rbac"]}).
- Indexes: idx_program_settings_merchant_id

API Sketch:
- POST /v1/api/settings/setup
  - Input: { merchant_id: string, task: string }
  - Output: { status: string, tasks_completed: array, error: { code: string, message: string } | null }
  - Flow: Validate task, update program_settings.config, include Plus-specific tasks, track via PostHog (e.g., `setup_task_completed`), enforce RBAC.

********************************************
Feature Name: Points Program Configuration
********************************************

Goal: Enable merchants to customize points earning and redemption rules to align with their business. Success metric: 85%+ configuration completion rate.

Key Features:
- Set earning rules (e.g., 1 point/$, 200 points for signup).
- Define redemption options (e.g., $5 off for 500 points) via GraphQL Admin API.
- Customize branding (e.g., points currency as "Stars").
- Toggle program on/off.

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - points_currency_singular (text, NOT NULL): Currency name (e.g., "Star").
  - points_currency_plural (text, NOT NULL): Plural form (e.g., "Stars").
  - config (jsonb, NOT NULL): Rules (e.g., {"purchase": 1, "signup": 200}).
  - branding (jsonb, NOT NULL): Branding settings (e.g., {"panel_color": "#FF0000"}).
- Table: rewards
  - points_cost (integer, NOT NULL, CHECK points_cost > 0): Points for redemption.
  - value (numeric, NOT NULL, CHECK value > 0): Reward value.
- Indexes: idx_program_settings_merchant_id

API Sketch:
- PUT /v1/api/points-program
  - Input: { merchant_id: string, config: { purchase: number, signup: number }, branding: { points_currency_singular: string, points_currency_plural: string } }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs (e.g., points_cost > 0), update program_settings and rewards via GraphQL Admin API, cache in Redis, enforce RBAC.

********************************************
Feature Name: Referrals Program Configuration
********************************************

Goal: Allow merchants to set up a referral program to drive customer acquisition. Success metric: 5%+ referral configuration adoption.

Key Features:
- Configure referral rewards (e.g., 10% off for both) via GraphQL Admin API.
- Enable SMS/email/social sharing via Twilio/Klaviyo with 3 retries.
- Preview referral popup with localized content.
- Toggle program on/off (Phase 2).

Database Design:
- Table: program_settings
  - config (jsonb, NOT NULL): Referral settings (e.g., {"reward": "10% off", "sms_enabled": true}).
- Table: email_templates
  - template_id (text, PK, NOT NULL): Referral email template.
  - type (text, NOT NULL): "referral".
  - subject (jsonb, NOT NULL): Multilingual subject.
  - body (jsonb, NOT NULL): Multilingual content.
- Indexes: idx_email_templates_merchant_id

API Sketch:
- PUT /v1/api/referrals/config
  - Input: { merchant_id: string, config: { reward: string, sms_enabled: boolean }, locale: string }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update program_settings.config, email_templates with localized content, notify via Twilio/Klaviyo with retries, enforce RBAC, cache in Redis.

********************************************
Feature Name: Customer Management
********************************************

Goal: Provide merchants with tools to view and manage customer data for better engagement. Success metric: 90%+ query performance under 1s.

Key Features:
- List customers with name, email (encrypted), points, RFM score.
- Search by name/email with pagination.
- View detailed customer profiles (e.g., points history).
- Handle large customer lists with pagination, support GDPR compliance.

Database Design:
- Table: customers
  - customer_id (text, PK, NOT NULL): Unique ID.
  - email (text, ENCRYPTED, NOT NULL): Customer email.
  - first_name (text), last_name (text): Customer name.
  - points_balance (integer, NOT NULL, DEFAULT 0): Current points.
  - rfm_score (jsonb, NOT NULL): RFM metrics (e.g., {"recency": 30, "frequency": 2}).
- Indexes: idx_customers_email, idx_customers_merchant_id
- Partition: customers by merchant_id for Plus-scale performance.

API Sketch:
- GET /v1/api/customers
  - Input: { merchant_id: string, search: string, page: number, per_page: number }
  - Output: { status: string, customers: array, total: number, error: { code: string, message: string } | null }
  - Flow: Query customers with pagination, search, and encrypted email handling via GraphQL Admin API, enforce GDPR webhooks (customers/data_request, customers/redact), cache in Redis.

********************************************
Feature Name: Analytics Dashboard
********************************************

Goal: Enable merchants to monitor loyalty program performance with metrics and RFM charts. Success metric: 80%+ merchant interaction with analytics.

Key Features:
- Display metrics (e.g., program members, points issued, referral ROI) via GraphQL Admin API.
- Show RFM segment charts (Chart.js) with real-time updates.
- Export reports as CSV (Phase 3).
- Cache metrics in Redis for Plus-scale performance.

Database Design:
- Table: customer_segments
  - segment_id (text, PK, NOT NULL): Unique segment ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - rules (jsonb, NOT NULL): RFM rules (e.g., {"recency": "<30 days"}).
- Table: points_transactions
  - For metrics like points issued/redeemed, partitioned by merchant_id.
- Table: customers
  - rfm_score (jsonb, NOT NULL): For segment calculations.
- Indexes: idx_customer_segments_merchant_id, idx_points_transactions_merchant_id
- Partition: customer_segments by merchant_id for Plus-scale performance.

API Sketch:
- GET /v1/api/analytics
  - Input: { merchant_id: string }
  - Output: { status: string, metrics: { members: number, points_issued: number, referral_roi: number }, segments: array, error: { code: string, message: string } | null }
  - Flow: Query customer_segments, points_transactions via GraphQL Admin API, cache in Redis, generate Chart.js data.

********************************************
Feature Name: Store Settings
********************************************

Goal: Allow merchants to configure store details and billing plans to manage their account. Success metric: 90%+ settings update success rate.

Key Features:
- Update store name, billing plan (e.g., Free: 300 orders, $29/mo: 500 orders) via GraphQL Admin API.
- Save branding settings (e.g., rewards panel style) with multilingual support.
- Validate inputs for consistency.
- Display current plan status, support multi-store for Plus.

Database Design:
- Table: merchants
  - merchant_id (text, PK, NOT NULL): Unique ID.
  - shopify_domain (text, UNIQUE, NOT NULL): Store domain.
  - plan_id (text, FK → plans): Billing plan.
  - brand_settings (jsonb, NOT NULL): Branding config (e.g., {"panel_color": "#FF0000"}).
  - staff_roles (jsonb, NOT NULL): RBAC roles for Plus (e.g., {"admin": ["full", "support"]}).
- Table: plans
  - plan_id (text, PK, NOT NULL): Plan ID.
  - order_limit (integer, NOT NULL, CHECK order_limit >= 0): Order cap.
  - base_price (numeric, NOT NULL, CHECK base_price >= 0): Plan cost.
- Indexes: idx_merchants_shopify_domain, idx_merchants_plan_id

API Sketch:
- PUT /v1/api/settings
  - Input: { merchant_id: string, store_name: string, plan_id: string, brand_settings: object, locale: string }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update merchants with multi-store support, enforce RBAC, cache in Redis.

********************************************
Feature Name: On-Site Content Management
********************************************

Goal: Enable merchants to customize loyalty page, popups, and launcher button to align with their brand. Success metric: 85%+ content customization adoption.

Key Features:
- Edit SEO-friendly loyalty page with multilingual support.
- Customize rewards panel and launcher button via Storefront API.
- Configure post-purchase and exit-intent popups (Phase 2) with localized content.
- Enable sticky bar (Phase 3) with engagement tracking.

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - branding (jsonb, NOT NULL): Content settings (e.g., {"loyalty_page": {"en": {...}, "es": {...}}, "popup": {...}, "sticky_bar": {...}}).
- Table: email_templates
  - template_id (text, PK, NOT NULL): For popup notifications.
  - type (text, NOT NULL): "popup".
  - subject (jsonb, NOT NULL): Multilingual subject.
  - body (jsonb, NOT NULL): Multilingual content.
- Indexes: idx_program_settings_merchant_id, idx_email_templates_merchant_id

API Sketch:
- PUT /v1/api/content
  - Input: { merchant_id: string, branding: { loyalty_page: object, popup: object, sticky_bar: object }, locale: string }
  - Output: { status: string, preview: object, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update program_settings.branding with multilingual content, use Storefront API, cache in Redis, track engagement via PostHog (e.g., `sticky_bar_click`).

********************************************
Feature Name: VIP Tiers Management (Phase 2)
********************************************

Goal: Allow merchants to define and manage VIP tiers to reward loyal customers. Success metric: 80%+ tier configuration adoption.

Key Features:
- Create/edit tiers (e.g., Silver, Gold) with spending thresholds via GraphQL Admin API.
- Set perks and multipliers, enforce RBAC for Plus.
- Notify customers of tier changes via Klaviyo.
- Preview tier structure in Dashboard.

Database Design:
- Table: vip_tiers
  - vip_tier_id (text, PK, NOT NULL): Unique ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - name (text, NOT NULL): Tier name.
  - threshold_value (numeric, NOT NULL, CHECK threshold_value >= 0): Spending threshold.
  - perks (jsonb, NOT NULL): Perks list.
  - earning_multiplier (numeric, NOT NULL, CHECK earning_multiplier >= 1): Points multiplier.
- Table: email_templates
  - template_id (text, PK, NOT NULL): For tier change notifications.
  - type (text, NOT NULL): "tier_change".
  - subject (jsonb, NOT NULL): Multilingual subject.
  - body (jsonb, NOT NULL): Multilingual content.
- Indexes: idx_vip_tiers_merchant_id
- Partition: vip_tiers by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/vip-tiers
  - Input: { merchant_id: string, name: string, threshold_value: number, perks: object, earning_multiplier: number }
  - Output: { status: string, vip_tier_id: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, insert into vip_tiers, update email_templates, enforce RBAC, cache in Redis.

********************************************
Feature Name: Activity Logs (Phase 2)
********************************************

Goal: Provide merchants with logs of customer actions for transparency and tracking. Success metric: 90%+ log query performance under 1s.

Key Features:
- Display points, referral, and VIP tier change logs with filters (customer, date, action type).
- Paginate large logs for Plus-scale performance.
- Show detailed action info.
- Cache logs in Redis.

Database Design:
- Table: points_transactions
  - transaction_id (text, PK, NOT NULL): For points logs.
  - type (text, NOT NULL): Action type.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
- Table: referrals
  - referral_id (text, PK, NOT NULL): For referral logs.
  - status (text, NOT NULL): Referral status.
- Table: customers
  - vip_tier_id (text, FK → vip_tiers): For tier change logs.
- Indexes: idx_points_transactions_merchant_id, idx_referrals_merchant_id
- Partition: points_transactions, referrals by merchant_id for Plus-scale performance.

API Sketch:
- GET /v1/api/logs
  - Input: { merchant_id: string, filter: { customer_id: string, date_range: object, action_type: string }, page: number, per_page: number }
  - Output: { status: string, logs: array, total: number, error: { code: string, message: string } | null }
  - Flow: Query points_transactions, referrals, customers with pagination and filters, cache in Redis, enforce RBAC.

********************************************
Feature Name: RFM Configuration (Phase 2)
********************************************

Goal: Enable merchants to configure RFM thresholds for customer segmentation. Success metric: 80%+ wizard completion rate.

Key Features:
- Set recency, frequency, monetary thresholds via wizard with real-time preview.
- Validate inputs (e.g., recency < 365 days).
- Save settings for analytics, cache in Redis.
- Preview segment distribution (Chart.js).

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - config (jsonb, NOT NULL): RFM thresholds (e.g., {"recency": "<30 days", "frequency": ">2", "monetary": ">100"}).
- Table: customer_segments
  - segment_id (text, PK, NOT NULL): Segment ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - rules (jsonb, NOT NULL): Segment rules.
  - name (text, NOT NULL): Segment name (e.g., "At-Risk").
- Indexes: idx_program_settings_merchant_id, idx_customer_segments_merchant_id
- Partition: customer_segments by merchant_id for Plus-scale performance.

API Sketch:
- PUT /v1/api/rfm/config
  - Input: { merchant_id: string, thresholds: { recency: string, frequency: number, monetary: number } }
  - Output: { status: string, segment_preview: array, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update program_settings.config, customer_segments via GraphQL Admin API, cache in Redis, return preview, enforce RBAC.

********************************************
Feature Name: Checkout Extensions (Phase 2)
********************************************

Goal: Display points balance at checkout to encourage redemptions. Success metric: 85%+ adoption for Plus merchants.

Key Features:
- Enable/disable points display in Shopify checkout via GraphQL Storefront API.
- Show balance and redemption options for Plus merchants (1,000 orders/hour).
- Integrate via Shopify API with rate limiting.
- Preview in Dashboard.

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - config (jsonb, NOT NULL): Checkout settings (e.g., {"checkout_enabled": true, "points_display": true}).
- Table: integrations
  - integration_id (text, PK, NOT NULL): Integration ID.
  - type (text, NOT NULL): "shopify".
  - settings (jsonb, NOT NULL): Checkout config.
- Indexes: idx_program_settings_merchant_id, idx_integrations_merchant_id

API Sketch:
- PUT /v1/api/content
  - Input: { merchant_id: string, checkout_config: { enabled: boolean, points_display: boolean } }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update program_settings.config, integrations.settings, use Storefront API for points display, enforce RBAC, cache in Redis.

********************************************
Feature Name: Bonus Campaigns (Phase 3)
********************************************

Goal: Allow merchants to create time-sensitive campaigns to boost engagement. Success metric: 20%+ campaign-driven engagement.

Key Features:
- Set campaign types (e.g., double points, goal spend) via GraphQL Admin API.
- Define start/end dates and multipliers.
- Notify customers via email/SMS with 3 retries (exponential backoff).
- Track campaign performance, cache in Redis.

Database Design:
- Table: bonus_campaigns
  - campaign_id (text, PK, NOT NULL): Unique ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL): Campaign type (e.g., "double_points").
  - multiplier (numeric, NOT NULL, CHECK multiplier >= 1): Points multiplier.
  - start_date (timestamp, NOT NULL): Campaign start.
  - end_date (timestamp, NOT NULL): Campaign end.
  - conditions (jsonb, NOT NULL): Campaign rules (e.g., {"min_spend": 50}).
- Table: points_transactions
  - transaction_id (text, PK): For campaign points.
  - type (text, NOT NULL): "campaign".
- Indexes: idx_bonus_campaigns_merchant_id
- Partition: bonus_campaigns by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/campaigns
  - Input: { merchant_id: string, type: string, multiplier: number, dates: { start: string, end: string }, conditions: object }
  - Output: { status: string, campaign_id: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, insert into bonus_campaigns, notify via Klaviyo with retries, cache in Redis, track via PostHog (e.g., `campaign_created`).

********************************************
Feature Name: Advanced Reports Export (Phase 3)
********************************************

Goal: Enable merchants to export detailed analytics for in-depth analysis. Success metric: 90%+ export completion under 5s.

Key Features:
- Export RFM segments and revenue data as CSV asynchronously.
- Show export progress via Redis.
- Ensure data accuracy with validation.
- Log export actions in api_logs.

Database Design:
- Table: customer_segments
  - segment_id (text, PK, NOT NULL): Segment ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - rules (jsonb, NOT NULL): Segment rules.
- Table: points_transactions
  - For revenue and redemption data.
- Table: api_logs
  - id (text, PK, NOT NULL): Log export actions.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
- Indexes: idx_customer_segments_merchant_id, idx_api_logs_merchant_id
- Partition: customer_segments by merchant_id for Plus-scale performance.

API Sketch:
- GET /v1/api/analytics/export
  - Input: { merchant_id: string }
  - Output: { status: string, export_id: string, progress: number, url: string, error: { code: string, message: string } | null }
  - Flow: Queue export job, query customer_segments, points_transactions via GraphQL Admin API, store in Redis, generate CSV, log in api_logs, track via PostHog (e.g., `export_completed`).

********************************************
Feature Name: Sticky Bar (Phase 3)
********************************************

Goal: Promote the loyalty program with a sticky bar on the store website. Success metric: 10%+ sticky bar click-through rate.

Key Features:
- Enable/disable sticky bar in Dashboard with multilingual content.
- Customize bar content and style via Storefront API.
- Preview in real-time.
- Track engagement via PostHog (e.g., `sticky_bar_click`).

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - branding (jsonb, NOT NULL): Sticky bar settings (e.g., {"sticky_bar": {"text": {"en": "Join Now!", "es": "¡Únete Ahora!"}, "style": {...}}}).
- Indexes: idx_program_settings_merchant_id

API Sketch:
- PUT /v1/api/content
  - Input: { merchant_id: string, sticky_bar: { text: object, style: object }, locale: string }
  - Output: { status: string, preview: object, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update program_settings.branding with multilingual content, use Storefront API, cache in Redis, track engagement via PostHog.

********************************************
Feature Name: Developer Toolkit (Phase 3)
********************************************

Goal: Provide advanced customization for merchants via metafields and APIs. Success metric: 50%+ toolkit adoption for Plus merchants.

Key Features:
- Configure metafields for Shopify integration via GraphQL Admin API.
- Save settings securely with validation.
- Test connectivity for metafield updates.
- Preview changes in Dashboard.

Database Design:
- Table: integrations
  - integration_id (text, PK, NOT NULL): Integration ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - settings (jsonb, NOT NULL): Metafield configs (e.g., {"metafields": {...}}).
- Table: api_logs
  - id (text, PK, NOT NULL): Log toolkit actions.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
- Indexes: idx_integrations_merchant_id, idx_api_logs_merchant_id

API Sketch:
- PUT /v1/api/settings/developer
  - Input: { merchant_id: string, metafields: object }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate metafields, update integrations.settings via GraphQL Admin API (e.g., metafieldSet), log in api_logs, cache in Redis, enforce RBAC.

## Admin Module Features (Phase 1, 2, 3)

********************************************
Feature Name: Merchant Overview
********************************************

Goal: Provide admins with a high-level view of platform usage and metrics. Success metric: 90%+ dashboard query performance under 1s.

Key Features:
- Display merchant count, points issued, referral ROI using GraphQL Admin API.
- Show aggregated RFM charts (Chart.js) with real-time updates.
- Filter by time period.
- Cache metrics in Redis for Plus-scale performance.

Database Design:
- Table: merchants
  - merchant_id (text, PK, NOT NULL): Unique ID.
  - shopify_domain (text, UNIQUE, NOT NULL): Store domain.
  - plan_id (text, FK → plans): Current plan.
- Table: points_transactions
  - For points metrics, partitioned by merchant_id.
- Table: customer_segments
  - For RFM data, partitioned by merchant_id.
- Indexes: idx_merchants_shopify_domain, idx_points_transactions_merchant_id, idx_customer_segments_merchant_id
- Partition: points_transactions, customer_segments by merchant_id for Plus-scale performance.

API Sketch:
- GET /admin/overview
  - Input: { period: string }
  - Output: { status: string, metrics: { merchant_count: number, points_issued: number, referral_roi: number }, charts: array, error: { code: string, message: string } | null }
  - Flow: Query merchants, points_transactions, customer_segments via GraphQL Admin API, cache in Redis, generate Chart.js data, enforce RBAC.

********************************************
Feature Name: Merchant Management
********************************************

Goal: Allow admins to view and manage merchant accounts for platform oversight. Success metric: 90%+ query performance under 1s.

Key Features:
- List merchants with ID, domain, plan, support multi-store for Plus.
- Search by ID/domain with pagination.
- View detailed merchant profiles with RBAC roles.
- Cache results in Redis.

Database Design:
- Table: merchants
  - merchant_id (text, PK, NOT NULL): Unique ID.
  - shopify_domain (text, UNIQUE, NOT NULL): Store domain.
  - plan_id (text, FK → plans): Current plan.
  - staff_roles (jsonb, NOT NULL): RBAC roles (e.g., {"admin": ["full", "support"]}).
- Indexes: idx_merchants_shopify_domain, idx_merchants_plan_id
- Partition: merchants by merchant_id for Plus-scale performance.

API Sketch:
- GET /admin/merchants
  - Input: { search: string, page: number, per_page: number }
  - Output: { status: string, merchants: array, total: number, error: { code: string, message: string } | null }
  - Flow: Query merchants with pagination, support multi-store profiles, enforce RBAC, cache in Redis.

********************************************
Feature Name: Points Adjustment
********************************************

Goal: Enable admins to adjust customer points for corrections or bonuses. Success metric: 95%+ adjustment success rate.

Key Features:
- Adjust points via form with validation.
- Log adjustments in audit_logs for auditing.
- Update customer balance via GraphQL Admin API.
- Notify customer of change via Klaviyo.

Database Design:
- Table: points_transactions
  - transaction_id (text, PK, NOT NULL): Adjustment record.
  - type (text, NOT NULL): "admin_adjust".
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
- Table: customers
  - points_balance (integer, NOT NULL): Updated balance.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log adjustment.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin performing action.
  - action (text, NOT NULL): Action details.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Log timestamp.
- Indexes: idx_points_transactions_merchant_id, idx_audit_logs_admin_user_id

API Sketch:
- POST /admin/points/adjust
  - Input: { merchant_id: string, customer_id: string, points: number }
  - Output: { status: string, transaction_id: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, insert into points_transactions, update customers.points_balance via GraphQL Admin API, log in audit_logs, notify via Klaviyo, enforce RBAC.

********************************************
Feature Name: Admin User Management
********************************************

Goal: Allow admins to manage platform access for other admins. Success metric: 100% secure user management operations.

Key Features:
- Add/edit/delete admin users with RBAC roles (e.g., superadmin, analytics).
- Validate unique username/email, use bcrypt for passwords.
- Log actions in audit_logs for security.
- Display admin list with roles.

Database Design:
- Table: admin_users
  - id (integer, PK, NOT NULL): Unique ID.
  - username (text, UNIQUE, NOT NULL): Unique username.
  - email (text, UNIQUE, NOT NULL, ENCRYPTED): Unique email.
  - password (text, NOT NULL): Hashed password (bcrypt).
  - metadata (jsonb, NOT NULL): RBAC roles (e.g., {"role": "superadmin"}).
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log user management actions.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
- Indexes: idx_admin_users_username, idx_admin_users_email, idx_audit_logs_admin_user_id

API Sketch:
- POST /admin/users
  - Input: { username: string, email: string, password: string, role: string }
  - Output: { status: string, id: number, error: { code: string, message: string } | null }
  - Flow: Validate inputs, hash password with bcrypt, insert into admin_users with RBAC role, log in audit_logs, enforce RBAC.
- PUT/DELETE /admin/users/{id}
  - Input: { username: string, email: string } (PUT)
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Update/delete admin_users, log in audit_logs, enforce RBAC.

********************************************
Feature Name: Log Management
********************************************

Goal: Provide admins with API and audit logs for platform monitoring. Success metric: 90%+ log query performance under 1s.

Key Features:
- Display API and audit logs with filters (date, route, status_code, user).
- Show detailed log info with pagination.
- Cache logs in Redis for Plus-scale performance.
- Ensure secure access with RBAC.

Database Design:
- Table: api_logs
  - id (text, PK, NOT NULL): Log ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - route (text, NOT NULL): API route.
  - method (text, NOT NULL): HTTP method.
  - status_code (integer, NOT NULL): Response code.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Log timestamp.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Audit log ID.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
  - action (text, NOT NULL): Action details.
- Indexes: idx_api_logs_merchant_id, idx_api_logs_route, idx_audit_logs_admin_user_id
- Partition: api_logs by merchant_id for Plus-scale performance.

API Sketch:
- GET /admin/logs
  - Input: { filter: { date: object, route: string, status_code: number, admin_user_id: number }, page: number, per_page: number }
  - Output: { status: string, logs: array, total: number, error: { code: string, message: string } | null }
  - Flow: Query api_logs, audit_logs with filters and pagination, cache in Redis, enforce RBAC.

********************************************
Feature Name: Plan Management (Phase 2)
********************************************

Goal: Allow admins to manage merchant billing plans for revenue control. Success metric: 95%+ plan update success rate.

Key Features:
- Upgrade/downgrade merchant plans (e.g., Free to $29/mo) with multi-store support for Plus.
- Display current plan and limits.
- Log plan changes in audit_logs.
- Notify merchants of changes via Klaviyo.

Database Design:
- Table: merchants
  - merchant_id (text, PK, NOT NULL): Unique ID.
  - plan_id (text, FK → plans): Current plan.
- Table: plans
  - plan_id (text, PK, NOT NULL): Plan ID.
  - order_limit (integer, NOT NULL, CHECK order_limit >= 0): Order cap.
  - base_price (numeric, NOT NULL, CHECK base_price >= 0): Cost.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log plan changes.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
- Indexes: idx_merchants_plan_id, idx_audit_logs_admin_user_id

API Sketch:
- PUT /admin/plans
  - Input: { merchant_id: string, plan_id: string }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update merchants.plan_id, support multi-store plans, log in audit_logs, notify via Klaviyo, enforce RBAC, cache in Redis.

********************************************
Feature Name: Integration Health Monitoring (Phase 2)
********************************************

Goal: Ensure platform reliability by monitoring integration status (e.g., Shopify, Twilio). Success metric: 95%+ integration uptime.

Key Features:
- Display integration status (e.g., "OK", "Error") for Shopify, Twilio, Klaviyo.
- Allow manual health checks with 3 retries (exponential backoff).
- Log checks in audit_logs.
- Notify admins of failures via email.

Database Design:
- Table: integrations
  - integration_id (text, PK, NOT NULL): Unique ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL, CHECK type IN ('shopify', 'twilio', 'klaviyo')): Integration type.
  - status (text, NOT NULL, CHECK status IN ('ok', 'error')): Health status.
  - settings (jsonb, NOT NULL): Integration config.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log health checks.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
- Indexes: idx_integrations_merchant_id, idx_audit_logs_admin_user_id

API Sketch:
- GET /admin/integrations/health
  - Input: { merchant_id: string, type: string }
  - Output: { status: string, integrations: [{ type: string, status: string, error: object }], error: { code: string, message: string } | null }
  - Flow: Query integrations, ping external APIs (e.g., Shopify /admin/api/2025-07/shop.json, Twilio /2010-04-01/Accounts), retry 3 times, log in audit_logs, cache in Redis, enforce RBAC.

********************************************
Feature Name: RFM Configuration Management (Phase 2)
********************************************

Goal: Allow admins to manage RFM settings for optimal customer segmentation. Success metric: 80%+ RFM configuration adoption.

Key Features:
- Configure RFM thresholds for merchants with real-time preview.
- Validate inputs (e.g., recency < 365 days).
- Save settings securely, cache in Redis.
- Log changes in audit_logs.

Database Design:
- Table: program_settings
  - merchant_id (text, PK, FK → merchants, NOT NULL): Merchant ID.
  - config (jsonb, NOT NULL): RFM thresholds (e.g., {"recency": "<30 days"}).
- Table: customer_segments
  - segment_id (text, PK, NOT NULL): Segment ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - rules (jsonb, NOT NULL): Segment rules.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log changes.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
- Indexes: idx_program_settings_merchant_id, idx_customer_segments_merchant_id
- Partition: customer_segments by merchant_id for Plus-scale performance.

API Sketch:
- PUT /admin/rfm
  - Input: { merchant_id: string, thresholds: { recency: string, frequency: number, monetary: number } }
  - Output: { status: string, segment_preview: array, error: { code: string, message: string } | null }
  - Flow: Validate inputs, update program_settings.config, customer_segments via GraphQL Admin API, cache in Redis, log in audit_logs, enforce RBAC.

********************************************
Feature Name: RFM Segment Export (Phase 3)
********************************************

Goal: Enable admins to export RFM segments for detailed analysis. Success metric: 90%+ export completion under 5s.

Key Features:
- Export segments as CSV asynchronously with progress tracking.
- Show export progress via Redis.
- Ensure data accuracy with validation.
- Log export actions in audit_logs.

Database Design:
- Table: customer_segments
  - segment_id (text, PK, NOT NULL): Segment ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - rules (jsonb, NOT NULL): Segment rules.
- Table: customers
  - rfm_score (jsonb, NOT NULL): Customer RFM data.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log exports.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
- Indexes: idx_customer_segments_merchant_id, idx_customers_rfm_score
- Partition: customer_segments by merchant_id for Plus-scale performance.

API Sketch:
- GET /admin/rfm/export
  - Input: { merchant_id: string }
  - Output: { status: string, export_id: string, progress: number, url: string, error: { code: string, message: string } | null }
  - Flow: Queue export job, query customer_segments, customers via GraphQL Admin API, store in Redis, generate CSV, log in audit_logs, track via PostHog (e.g., `rfm_export`).

********************************************
Feature Name: Advanced Integrations (Phase 3)
********************************************

Goal: Support additional platforms (e.g., Square, Lightspeed) for broader compatibility. Success metric: 50%+ integration adoption for Plus merchants.

Key Features:
- Configure new integrations (Square /v2/payments, Lightspeed /api/2.0/sales, Gorgias /api/tickets, Yotpo /v1/reviews, Postscript /sms/messages) via API keys/OAuth.
- Save settings securely with validation.
- Test integration connectivity with 3 retries.
- Log setup actions in audit_logs.

Database Design:
- Table: integrations
  - integration_id (text, PK, NOT NULL): Unique ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL, CHECK type IN ('square', 'lightspeed', 'gorgias', 'yotpo', 'postscript')): Platform type.
  - api_key (text, ENCRYPTED): API key.
  - settings (jsonb, NOT NULL): Integration config.
- Table: audit_logs
  - id (uuid, PK, NOT NULL): Log setup actions.
  - admin_user_id (integer, FK → admin_users, NOT NULL): Admin action.
- Indexes: idx_integrations_merchant_id, idx_audit_logs_admin_user_id

API Sketch:
- POST /admin/integrations
  - Input: { merchant_id: string, type: string, api_key: string, settings: object }
  - Output: { status: string, integration_id: string, error: { code: string, message: string } | null }
  - Flow: Validate API key, insert into integrations, test connectivity (e.g., Square /v2/payments), log in audit_logs, cache in Redis, enforce RBAC.

## Backend Integration Features (Phase 1, 2, 3)

********************************************
Feature Name: Shopify Order Sync
********************************************

Goal: Automatically sync Shopify orders to award points seamlessly. Success metric: 95%+ sync success rate.

Key Features:
- Receive `orders/create` webhooks with signature verification.
- Calculate and award points based on rules via GraphQL Admin API.
- Update customer balance and cache in Redis.
- Log sync actions in api_logs.

Database Design:
- Table: points_transactions
  - transaction_id (text, PK, NOT NULL): Sync record.
  - type (text, NOT NULL): "purchase".
  - order_id (text, NOT NULL): Shopify order ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - created_at (timestamp, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Transaction timestamp.
- Table: customers
  - points_balance (integer, NOT NULL): Updated balance.
- Table: api_logs
  - id (text, PK, NOT NULL): Log webhook calls.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - route (text, NOT NULL): API route.
- Indexes: idx_points_transactions_order_id, idx_api_logs_merchant_id
- Partition: points_transactions by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/points/earn
  - Input: { order_id: string, customer_id: string }
  - Output: { status: string, transaction_id: string, points: number, error: { code: string, message: string } | null }
  - Flow: Verify webhook signature, validate order via GraphQL Admin API, insert into points_transactions, update customers.points_balance, cache in Redis, handle rate limits (2 req/s REST, 40 req/s Plus), track via PostHog (e.g., `order_synced`).
- GraphQL Query (Admin API):
  - Query: order(id: "gid://shopify/Order/123") { id, totalPrice, customer { id } }
  - Flow: Validate order, calculate points.

********************************************
Feature Name: Referral Notifications
********************************************

Goal: Notify customers of referral rewards via email/SMS for engagement. Success metric: 90%+ notification delivery rate.

Key Features:
- Send notifications using Twilio/Klaviyo with 3 retries (exponential backoff).
- Use merchant-defined templates with multilingual support.
- Log notification events in email_events.
- Handle delivery failures with retries.

Database Design:
- Table: email_templates
  - template_id (text, PK, NOT NULL): Notification template.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - type (text, NOT NULL): "referral".
  - subject (jsonb, NOT NULL): Multilingual subject.
  - body (jsonb, NOT NULL): Multilingual content.
- Table: email_events
  - event_id (text, PK, NOT NULL): Event ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - event_type (text, NOT NULL): "sent".
  - recipient_email (text, ENCRYPTED): Target email.
- Indexes: idx_email_templates_merchant_id, idx_email_events_merchant_id

API Sketch:
- POST /v1/api/notifications/send
  - Input: { template_id: string, recipient_email: string, locale: string }
  - Output: { status: string, error: { code: string, message: string } | null }
  - Flow: Query email_templates with localized content, send via Twilio/Klaviyo with retries, insert into email_events, cache in Redis, track via PostHog (e.g., `notification_sent`).

********************************************
Feature Name: Customer Data Import (Phase 2)
********************************************

Goal: Import existing customer data from integrations to onboard merchants. Success metric: 95%+ import success rate.

Key Features:
- Import customer records via API with validation (email format, duplicates).
- Log import success/failures in import_logs with detailed errors.
- Update customer records via GraphQL Admin API.
- Cache results in Redis.

Database Design:
- Table: customers
  - customer_id (text, PK, NOT NULL): Imported customer.
  - email (text, ENCRYPTED, NOT NULL): Customer email.
  - first_name (text), last_name (text): Customer name.
- Table: import_logs
  - id (text, PK, NOT NULL): Log ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - success_count (integer, NOT NULL, DEFAULT 0): Successful imports.
  - fail_count (integer, NOT NULL, DEFAULT 0): Failed imports.
  - fail_reason (jsonb): Error details (e.g., {"email": "Invalid format"}).
- Indexes: idx_customers_email, idx_import_logs_merchant_id

API Sketch:
- POST /v1/api/data/import
  - Input: { merchant_id: string, customers: [{ email: string, first_name: string, last_name: string }] }
  - Output: { status: string, success_count: number, fail_count: number, errors: array, error: { code: string, message: string } | null }
  - Flow: Validate customer data, insert into customers via GraphQL Admin API, log successes/failures in import_logs, cache in Redis, track via PostHog (e.g., `data_imported`).

********************************************
Feature Name: Campaign Discounts (Phase 3)
********************************************

Goal: Apply discounts from bonus campaigns to enhance customer rewards. Success metric: 20%+ campaign-driven redemption rate.

Key Features:
- Check active campaigns for point multipliers via GraphQL Admin API.
- Apply discounts via Rust/Wasm Shopify Functions.
- Update points and cache in Redis.
- Log campaign applications in api_logs.

Database Design:
- Table: bonus_campaigns
  - campaign_id (text, PK, NOT NULL): Campaign ID.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
  - multiplier (numeric, NOT NULL, CHECK multiplier >= 1): Points multiplier.
  - conditions (jsonb, NOT NULL): Campaign rules.
- Table: points_transactions
  - transaction_id (text, PK): For campaign points.
  - type (text, NOT NULL): "campaign".
- Table: api_logs
  - id (text, PK, NOT NULL): Log discount applications.
  - merchant_id (text, FK → merchants, NOT NULL): Associated merchant.
- Indexes: idx_bonus_campaigns_merchant_id, idx_api_logs_merchant_id
- Partition: bonus_campaigns by merchant_id for Plus-scale performance.

API Sketch:
- POST /v1/api/campaigns/apply
  - Input: { customer_id: string, order_id: string }
  - Output: { status: string, points: number, discount_code: string, error: { code: string, message: string } | null }
  - Flow: Query bonus_campaigns, apply multiplier via GraphQL Admin API, insert into points_transactions, log in api_logs, cache in Redis, track via PostHog (e.g., `campaign_applied`).